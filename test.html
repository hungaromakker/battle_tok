<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Typing World</title>
  <style>
    :root {
      --panel: rgba(255, 255, 255, 0.12);
      --panel2: rgba(255, 255, 255, 0.08);
      --txt: rgba(255, 255, 255, 0.92);
      --muted: rgba(255, 255, 255, 0.68);
      --shadow: rgba(0, 0, 0, 0.25);
      --good: rgba(120, 255, 170, 0.95);
      --bad: rgba(255, 120, 140, 0.95);
      --warn: rgba(255, 230, 140, 0.95);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: #0b1020;
      font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif;
    }

    #app {
      position: relative;
      width: 100%;
      height: 100%;
      user-select: none;
    }

    /* animated background */
    #bg {
      position: absolute;
      inset: -20%;
      background:
        radial-gradient(closest-side at 20% 30%, rgba(255, 90, 160, 0.55), transparent 60%),
        radial-gradient(closest-side at 80% 25%, rgba(70, 190, 255, 0.55), transparent 60%),
        radial-gradient(closest-side at 65% 75%, rgba(255, 220, 90, 0.50), transparent 60%),
        radial-gradient(closest-side at 30% 80%, rgba(110, 255, 170, 0.45), transparent 60%),
        linear-gradient(135deg, #0b1020, #131a36 40%, #0b1020);
      filter: blur(0px) saturate(1.25);
      animation: drift 14s ease-in-out infinite alternate;
      transform: translate3d(0, 0, 0);
    }

    @keyframes drift {
      0% {
        transform: translate(-1%, -1%) scale(1.02) rotate(-0.5deg);
      }

      100% {
        transform: translate(1.5%, 1.2%) scale(1.06) rotate(0.6deg);
      }
    }

    /* blobs */
    .blob {
      position: absolute;
      width: 360px;
      height: 360px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.45), rgba(255, 255, 255, 0.10) 45%, transparent 70%);
      filter: blur(2px);
      opacity: 0.55;
      mix-blend-mode: screen;
      animation: floaty 8s ease-in-out infinite alternate;
      pointer-events: none;
    }

    .blob.b1 {
      left: 6%;
      top: 12%;
      animation-duration: 10s;
      transform: scale(1.05);
    }

    .blob.b2 {
      right: 8%;
      top: 18%;
      animation-duration: 12s;
      transform: scale(0.95);
    }

    .blob.b3 {
      left: 18%;
      bottom: 8%;
      animation-duration: 11s;
      transform: scale(1.15);
    }

    @keyframes floaty {
      0% {
        transform: translate(0, 0) scale(1);
      }

      100% {
        transform: translate(30px, -18px) scale(1.05);
      }
    }

    /* layout */
    #ui {
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
      padding: 14px;
      color: var(--txt);
    }

    #topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 18px;
      box-shadow: 0 14px 40px var(--shadow);
      backdrop-filter: blur(10px);
    }

    #stats {
      padding: 12px 14px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .pill {
      padding: 7px 10px;
      background: var(--panel2);
      border: 1px solid rgba(255, 255, 255, 0.10);
      border-radius: 999px;
      display: flex;
      gap: 8px;
      align-items: baseline;
    }

    .pill b {
      font-weight: 700;
    }

    .pill span {
      color: var(--muted);
      font-size: 12px;
    }

    #controls {
      padding: 12px 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    #controls .left,
    #controls .right {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    select,
    button {
      appearance: none;
      background: rgba(255, 255, 255, 0.10);
      border: 1px solid rgba(255, 255, 255, 0.14);
      color: var(--txt);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
      cursor: pointer;
    }

    button:hover,
    select:hover {
      background: rgba(255, 255, 255, 0.14);
    }

    button:active {
      transform: translateY(1px);
    }

    #main {
      display: grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap: 12px;
      min-height: 0;
    }

    #play {
      position: relative;
      min-height: 0;
      overflow: hidden;
    }

    #prompt {
      padding: 16px 16px 12px 16px;
    }

    #prompt h1 {
      margin: 0 0 6px 0;
      font-size: 28px;
      letter-spacing: -0.5px;
    }

    #prompt .sub {
      color: var(--muted);
      font-size: 14px;
      line-height: 1.25rem;
    }

    #big {
      padding: 8px 16px 16px 16px;
      display: flex;
      gap: 12px;
      align-items: stretch;
    }

    #card {
      flex: 1;
      background: rgba(0, 0, 0, 0.18);
      border: 1px solid rgba(255, 255, 255, 0.10);
      border-radius: 18px;
      padding: 14px;
      position: relative;
      overflow: hidden;
    }

    #card:before {
      content: "";
      position: absolute;
      inset: -1px;
      background: radial-gradient(closest-side at 20% 20%, rgba(255, 255, 255, 0.12), transparent 60%),
        radial-gradient(closest-side at 80% 20%, rgba(255, 255, 255, 0.10), transparent 60%),
        radial-gradient(closest-side at 50% 80%, rgba(255, 255, 255, 0.08), transparent 60%);
      pointer-events: none;
    }

    #taskLine {
      position: relative;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
    }

    #taskTitle {
      font-size: 14px;
      color: var(--muted);
      margin: 0;
    }

    #modeBadge {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.85);
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.10);
      border: 1px solid rgba(255, 255, 255, 0.12);
      white-space: nowrap;
    }

    #target {
      position: relative;
      margin-top: 10px;
      font-size: 44px;
      font-weight: 800;
      letter-spacing: 0.5px;
      text-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
    }

    #progress {
      position: relative;
      margin-top: 12px;
      height: 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.10);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.10);
    }

    #progress>div {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(120, 255, 170, 0.95), rgba(70, 190, 255, 0.95), rgba(255, 220, 90, 0.95));
      border-radius: 999px;
      transition: width 120ms ease;
    }

    #typed {
      position: relative;
      margin-top: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 18px;
      padding: 12px;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.10);
      color: rgba(255, 255, 255, 0.92);
      min-height: 46px;
      display: flex;
      align-items: center;
      gap: 8px;
      overflow: hidden;
    }

    #typed .ok {
      color: var(--good);
      font-weight: 700;
    }

    #typed .no {
      color: var(--bad);
      font-weight: 700;
    }

    #side {
      min-height: 0;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    #tips {
      padding: 12px 14px;
    }

    #tips h2 {
      margin: 0 0 6px 0;
      font-size: 16px;
    }

    #tips ul {
      margin: 6px 0 0 18px;
      padding: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.2rem;
    }

    #keyboard {
      padding: 12px 10px 10px 10px;
      display: flex;
      flex-direction: column;
      gap: 7px;
    }

    .row {
      display: flex;
      gap: 6px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .k {
      min-width: 36px;
      padding: 10px 10px;
      text-align: center;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.10);
      font-weight: 650;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.85);
      transition: transform 70ms ease, background 120ms ease, border 120ms ease, box-shadow 120ms ease;
    }

    .k.wide {
      min-width: 70px;
    }

    .k.space {
      min-width: 260px;
    }

    .k.hot {
      background: rgba(255, 230, 140, 0.22);
      border-color: rgba(255, 230, 140, 0.55);
      box-shadow: 0 10px 26px rgba(255, 230, 140, 0.15);
      transform: translateY(-1px) scale(1.03);
      color: rgba(255, 255, 255, 0.95);
    }

    .k.hit {
      background: rgba(120, 255, 170, 0.22);
      border-color: rgba(120, 255, 170, 0.60);
    }

    .k.miss {
      background: rgba(255, 120, 140, 0.18);
      border-color: rgba(255, 120, 140, 0.55);
    }

    /* particles */
    .p {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0.95;
      transform: translate(-50%, -50%);
      animation: puff 700ms ease-out forwards;
    }

    @keyframes puff {
      0% {
        transform: translate(-50%, -50%) scale(0.7);
        opacity: 0.9;
      }

      100% {
        transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(0.1);
        opacity: 0;
      }
    }

    /* confetti */
    .c {
      position: absolute;
      width: 10px;
      height: 16px;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0.95;
      transform: translate(-50%, -50%);
      animation: fall 900ms ease-in forwards;
    }

    @keyframes fall {
      0% {
        transform: translate(-50%, -50%) rotate(0deg);
        opacity: 1;
      }

      100% {
        transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) rotate(260deg);
        opacity: 0;
      }
    }

    /* screen shake */
    .shake {
      animation: shake 200ms ease;
    }

    @keyframes shake {
      0% {
        transform: translate(0, 0);
      }

      25% {
        transform: translate(4px, -2px);
      }

      50% {
        transform: translate(-3px, 2px);
      }

      75% {
        transform: translate(2px, 3px);
      }

      100% {
        transform: translate(0, 0);
      }
    }

    /* overlay start */
    #overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 50;
      background: rgba(0, 0, 0, 0.40);
      backdrop-filter: blur(8px);
    }

    #overlay .box {
      max-width: 760px;
      width: min(760px, 96vw);
      padding: 18px;
      border-radius: 22px;
    }

    #overlay h1 {
      margin: 0 0 6px 0;
      font-size: 26px;
    }

    #overlay p {
      margin: 8px 0;
      color: var(--muted);
      line-height: 1.35rem;
    }

    #overlay .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    #overlay .mini {
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.10);
      border-radius: 16px;
      padding: 10px 12px;
      color: rgba(255, 255, 255, 0.88);
      font-size: 13px;
    }

    #overlay .startRow {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    #overlay .startRow button {
      font-weight: 700;
    }

    #overlay .note {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.65);
    }

    @media (max-width: 860px) {
      #main {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="bg"></div>
    <div class="blob b1"></div>
    <div class="blob b2"></div>
    <div class="blob b3"></div>

    <div id="ui">
      <div id="topbar">
        <div id="stats" class="panel">
          <div class="pill"><b id="statScore">0</b><span>score</span></div>
          <div class="pill"><b id="statStreak">0</b><span>streak</span></div>
          <div class="pill"><b id="statAcc">100%</b><span>accuracy</span></div>
          <div class="pill"><b id="statWpm">0</b><span>wpm</span></div>
          <div class="pill"><b id="statLevel">1</b><span>level</span></div>
        </div>

        <div id="controls" class="panel">
          <div class="left">
            <select id="mode">
              <option value="letters">Letters (key training)</option>
              <option value="words">Words (type the word)</option>
              <option value="match">Match (type translation)</option>
            </select>

            <select id="lang">
              <option value="en">English</option>
              <option value="hu">Hungarian</option>
              <option value="de">German</option>
            </select>

            <select id="difficulty">
              <option value="easy">Easy</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Hard</option>
            </select>
          </div>

          <div class="right">
            <button id="btnNext">Next</button>
            <button id="btnReset">Reset</button>
          </div>
        </div>
      </div>

      <div id="main">
        <div id="play" class="panel">
          <div id="prompt">
            <h1 id="headline">Typing World</h1>
            <div class="sub" id="subtitle">Type what you see. Learn keys, letters, and words. Works best in fullscreen.
            </div>
          </div>

          <div id="big">
            <div id="card">
              <div id="taskLine">
                <div id="taskTitle">Target</div>
                <div id="modeBadge">Letters</div>
              </div>
              <div id="target">A</div>
              <div id="progress">
                <div id="bar"></div>
              </div>
              <div id="typed"><span id="typedInner"></span></div>
            </div>
          </div>
        </div>

        <div id="side">
          <div id="tips" class="panel">
            <h2>How this teaches “computer interaction”</h2>
            <ul>
              <li>Keyboard mapping: you see the next required key and the keyboard highlights it.</li>
              <li>Feedback loop: every input produces sound + visuals + score changes.</li>
              <li>Error handling: wrong keys show red feedback and reduce streak.</li>
              <li>Language mode: you can type words from different languages (“dataset”).</li>
            </ul>
          </div>

          <div id="keyboard" class="panel"></div>
        </div>
      </div>

      <div class="panel"
        style="padding:10px 14px; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap; color:rgba(255,255,255,0.75); font-size:12px;">
        <div>Click once to enable sound + fullscreen. Exit fullscreen via F11.</div>
        <div id="status">Ready</div>
      </div>
    </div>

    <div id="overlay">
      <div class="box panel">
        <h1>Start</h1>
        <p>Click “Enter Fullscreen” to enable audio + fullscreen (browser requirement). Then type.</p>
        <div class="grid">
          <div class="mini"><b>Letters mode</b><br />Teaches key positions and finger movement.</div>
          <div class="mini"><b>Words mode</b><br />Teaches spelling and speed (WPM).</div>
          <div class="mini"><b>Match mode</b><br />Shows word + translation, you type the answer.</div>
          <div class="mini"><b>Dataset</b><br />Built-in word lists per language; can also load JSON.</div>
        </div>
        <div class="startRow">
          <button id="btnStart">Enter Fullscreen</button>
          <button id="btnNoFs">Start (no fullscreen)</button>
          <span class="note">ESC may exit fullscreen depending on browser; F11 is reliable.</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // -------------------------
      // "Database" (embedded). Extend or replace with external JSON.
      // Schema option A (words mode): {words:[...]}
      // Schema option B (match mode): {pairs:[{q:"cat", a:"macska"}]}
      // -------------------------
      const DB = {
        en: {
          words: ["cat", "dog", "house", "castle", "market", "smith", "wood", "stone", "iron", "river", "forest", "bread", "shield", "sword", "wagon", "village", "coin", "trade", "repair", "build", "harvest", "storm", "bridge"],
          pairs: [
            { q: "cat", a: "macska" },
            { q: "dog", a: "kutya" },
            { q: "house", a: "ház" },
            { q: "castle", a: "vár" },
            { q: "market", a: "piac" }
          ]
        },
        hu: {
          words: ["alma", "körte", "kenyér", "híd", "erdő", "folyó", "vár", "piac", "kalapács", "pajzs", "kard", "szekér", "faluba", "érme", "csere", "javít", "épít", "arat"],
          pairs: [
            { q: "alma", a: "apple" },
            { q: "kenyér", a: "bread" },
            { q: "erdő", a: "forest" },
            { q: "híd", a: "bridge" },
            { q: "vár", a: "castle" }
          ]
        },
        de: {
          words: ["haus", "burg", "markt", "fluss", "wald", "brot", "schild", "schwert", "wagen", "dorf", "münze", "handel", "bauen", "ernten", "brücke", "sturm"],
          pairs: [
            { q: "haus", a: "house" },
            { q: "brot", a: "bread" },
            { q: "wald", a: "forest" },
            { q: "brücke", a: "bridge" },
            { q: "burg", a: "castle" }
          ]
        }
      };

      // Optional: external JSON loader (same schema as DB[lang]).
      // Put words_en.json next to the html and call loadExternal("en","words_en.json").
      async function loadExternal(lang, url) {
        const r = await fetch(url, { cache: "no-store" });
        if (!r.ok) throw new Error("Failed to load: " + url);
        const data = await r.json();
        DB[lang] = data;
      }

      // -------------------------
      // UI elements
      // -------------------------
      const el = (id) => document.getElementById(id);

      const overlay = el("overlay");
      const btnStart = el("btnStart");
      const btnNoFs = el("btnNoFs");

      const modeSel = el("mode");
      const langSel = el("lang");
      const diffSel = el("difficulty");

      const btnNext = el("btnNext");
      const btnReset = el("btnReset");

      const targetEl = el("target");
      const typedInner = el("typedInner");
      const bar = el("bar");
      const modeBadge = el("modeBadge");
      const statusEl = el("status");

      const statScore = el("statScore");
      const statStreak = el("statStreak");
      const statAcc = el("statAcc");
      const statWpm = el("statWpm");
      const statLevel = el("statLevel");

      const playPanel = el("play");
      const keyboard = el("keyboard");

      // -------------------------
      // Audio (simple synth)
      // -------------------------
      let audioCtx = null;

      function ensureAudio() {
        if (audioCtx) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }

      function tone(freq, duration = 0.08, type = "square", gainVal = 0.12) {
        if (!audioCtx) return;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.value = gainVal;
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
        o.connect(g).connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + duration);
      }

      function sfxKey() { tone(420 + Math.random() * 240, 0.05, "square", 0.08); }
      function sfxGood() { tone(660, 0.06, "triangle", 0.14); setTimeout(() => tone(990, 0.07, "triangle", 0.12), 35); }
      function sfxBad() { tone(160, 0.09, "sawtooth", 0.12); }

      // -------------------------
      // Game state
      // -------------------------
      const LETTERS = "ASDFGHJKLQWERTYUIZXCVBNM";
      const LETTERS_EASY = "ASDFJKL";
      const LETTERS_HARD = "QWERTYUIOPASDFGHJKLZXCVBNM";

      let state = {
        mode: "letters",
        lang: "en",
        diff: "normal",
        target: "A",
        targetDisplay: "A",
        answer: "A",
        typed: "",
        score: 0,
        streak: 0,
        hits: 0,
        total: 0,
        level: 1,
        startedAt: 0,
        lastWordStart: 0,
        typedCharsForWpm: 0
      };

      function setStatus(msg) { statusEl.textContent = msg; }

      // -------------------------
      // Keyboard rendering + highlight
      // -------------------------
      const KEY_LAYOUT = [
        ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"],
        ["A", "S", "D", "F", "G", "H", "J", "K", "L"],
        ["Z", "X", "C", "V", "B", "N", "M"]
      ];

      const SPECIAL = [
        [{ t: "Shift", k: "SHIFT", wide: true }, { t: "Space", k: " ", space: true }, { t: "Backspace", k: "BACKSPACE", wide: true }],
        [{ t: "Enter", k: "ENTER", wide: true }, { t: "Tab", k: "TAB", wide: true }, { t: "Esc", k: "ESC", wide: true }]
      ];

      const keyMap = new Map(); // label -> element

      function buildKeyboard() {
        keyboard.innerHTML = "";
        keyMap.clear();

        KEY_LAYOUT.forEach(row => {
          const r = document.createElement("div");
          r.className = "row";
          row.forEach(k => {
            const d = document.createElement("div");
            d.className = "k";
            d.textContent = k;
            r.appendChild(d);
            keyMap.set(k, d);
          });
          keyboard.appendChild(r);
        });

        // special row
        const r2 = document.createElement("div");
        r2.className = "row";
        SPECIAL[0].forEach(s => {
          const d = document.createElement("div");
          d.className = "k" + (s.wide ? " wide" : "") + (s.space ? " space" : "");
          d.textContent = s.t;
          r2.appendChild(d);
          keyMap.set(s.k, d);
        });
        keyboard.appendChild(r2);
      }

      function clearKeyClasses() {
        for (const v of keyMap.values()) {
          v.classList.remove("hot", "hit", "miss");
        }
      }

      function highlightExpectedKey() {
        clearKeyClasses();
        const expect = expectedKeyLabel();
        const k = keyMap.get(expect);
        if (k) k.classList.add("hot");
      }

      function flashKey(label, ok) {
        const k = keyMap.get(label);
        if (!k) return;
        k.classList.remove("hit", "miss");
        k.classList.add(ok ? "hit" : "miss");
        setTimeout(() => k.classList.remove("hit", "miss"), 160);
      }

      function expectedKeyLabel() {
        // For letters mode: expect exactly the target letter.
        // For words/match: expect next character in answer (SPACE allowed).
        if (state.mode === "letters") {
          return state.answer.toUpperCase();
        }
        const next = state.answer[state.typed.length] || "";
        if (next === " ") return " ";
        const up = next.toUpperCase();
        if (keyMap.has(up)) return up;
        // For accented letters, we cannot map reliably on a US keyboard UI.
        // In that case do not highlight a specific key.
        return up;
      }

      // -------------------------
      // Visual effects
      // -------------------------
      function particleBurst(x, y, count = 14) {
        for (let i = 0; i < count; i++) {
          const p = document.createElement("div");
          p.className = "p";
          p.style.left = x + "px";
          p.style.top = y + "px";
          p.style.background = `hsl(${Math.random() * 360}, 85%, 65%)`;
          p.style.setProperty("--dx", (Math.random() * 220 - 110) + "px");
          p.style.setProperty("--dy", (Math.random() * 200 - 120) + "px");
          playPanel.appendChild(p);
          setTimeout(() => p.remove(), 750);
        }
      }

      function confetti(x, y, count = 18) {
        for (let i = 0; i < count; i++) {
          const c = document.createElement("div");
          c.className = "c";
          c.style.left = x + "px";
          c.style.top = y + "px";
          c.style.background = `hsl(${Math.random() * 360}, 85%, 65%)`;
          c.style.setProperty("--dx", (Math.random() * 520 - 260) + "px");
          c.style.setProperty("--dy", (240 + Math.random() * 340) + "px");
          playPanel.appendChild(c);
          setTimeout(() => c.remove(), 950);
        }
      }

      function shake() {
        playPanel.classList.remove("shake");
        // force reflow
        void playPanel.offsetWidth;
        playPanel.classList.add("shake");
      }

      // -------------------------
      // Target generation
      // -------------------------
      function pickLetter() {
        const d = state.diff;
        let pool = LETTERS;
        if (d === "easy") pool = LETTERS_EASY;
        else if (d === "hard") pool = LETTERS_HARD;

        const ch = pool[(Math.random() * pool.length) | 0];
        return ch;
      }

      function pickWord() {
        const set = DB[state.lang] || DB.en;
        const words = set.words && set.words.length ? set.words : DB.en.words;
        let w = words[(Math.random() * words.length) | 0];
        if (state.diff === "easy") {
          // prefer shorter
          const short = words.filter(x => x.length <= 5);
          if (short.length) w = short[(Math.random() * short.length) | 0];
        } else if (state.diff === "hard") {
          // prefer longer
          const long = words.filter(x => x.length >= 7);
          if (long.length) w = long[(Math.random() * long.length) | 0];
        }
        return w;
      }

      function pickPair() {
        const set = DB[state.lang] || DB.en;
        const pairs = set.pairs && set.pairs.length ? set.pairs : DB.en.pairs;
        return pairs[(Math.random() * pairs.length) | 0];
      }

      function setNewTarget() {
        state.typed = "";
        typedInner.innerHTML = "";
        bar.style.width = "0%";

        const m = state.mode;
        if (m === "letters") {
          const letter = pickLetter();
          state.target = letter;
          state.targetDisplay = letter;
          state.answer = letter;
          modeBadge.textContent = "Letters";
          el("taskTitle").textContent = "Press this key";
          targetEl.textContent = letter;
        } else if (m === "words") {
          const w = pickWord();
          state.target = w;
          state.targetDisplay = w;
          state.answer = w;
          modeBadge.textContent = "Words";
          el("taskTitle").textContent = "Type this word";
          targetEl.textContent = w;
          state.lastWordStart = performance.now();
        } else {
          const p = pickPair();
          // Display question, answer is translation.
          // Example: in HU mode pairs have q=alma, a=apple => you type english.
          state.target = p.q;
          state.targetDisplay = `${p.q} → ${p.a.length ? "?" : ""}`;
          state.answer = p.a;
          modeBadge.textContent = "Match";
          el("taskTitle").textContent = "Type the translation";
          targetEl.textContent = `${p.q} → ?`;
          state.lastWordStart = performance.now();
        }

        highlightExpectedKey();
        setStatus("Target ready");
      }

      // -------------------------
      // Scoring, WPM, accuracy
      // -------------------------
      function updateStats() {
        statScore.textContent = String(state.score);
        statStreak.textContent = String(state.streak);

        const acc = state.total ? Math.round((state.hits / state.total) * 100) : 100;
        statAcc.textContent = acc + "%";

        // WPM: (chars/5) / minutes
        const now = performance.now();
        const elapsedMs = Math.max(1, now - state.startedAt);
        const minutes = elapsedMs / 60000;
        const wpm = Math.max(0, Math.round((state.typedCharsForWpm / 5) / minutes));
        statWpm.textContent = String(wpm);

        statLevel.textContent = String(state.level);
      }

      function levelUpIfNeeded() {
        // simple progression: every 200 score -> level up
        const newLevel = 1 + Math.floor(state.score / 200);
        if (newLevel !== state.level) {
          state.level = newLevel;
          setStatus("Level " + state.level);
        }
      }

      // -------------------------
      // Typed display (green correct prefix)
      // -------------------------
      function renderTyped() {
        const ans = state.answer;
        const typed = state.typed;

        let okPrefixLen = 0;
        while (okPrefixLen < typed.length && okPrefixLen < ans.length && typed[okPrefixLen] === ans[okPrefixLen]) {
          okPrefixLen++;
        }

        const ok = typed.slice(0, okPrefixLen);
        const rest = typed.slice(okPrefixLen);

        const okHtml = ok ? `<span class="ok">${escapeHtml(ok)}</span>` : "";
        const restHtml = rest ? `<span class="no">${escapeHtml(rest)}</span>` : "";
        typedInner.innerHTML = okHtml + restHtml;

        const pct = ans.length ? Math.min(100, Math.floor((okPrefixLen / ans.length) * 100)) : 0;
        bar.style.width = pct + "%";
      }

      function escapeHtml(s) {
        return s.replace(/[&<>"']/g, m => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" }[m]));
      }

      // -------------------------
      // Input handling
      // -------------------------
      function normalizeKey(e) {
        if (e.key === " ") return " ";
        if (e.key === "Backspace") return "BACKSPACE";
        if (e.key === "Enter") return "ENTER";
        if (e.key === "Tab") return "TAB";
        if (e.key === "Escape") return "ESC";
        if (e.key.length === 1) return e.key;
        return e.key;
      }

      function onCorrect(e, label, x, y) {
        state.hits++;
        state.total++;
        state.streak++;
        state.score += 10 + Math.min(25, state.streak); // streak bonus
        state.typedCharsForWpm += 1;

        flashKey(label, true);
        particleBurst(x, y, 14);
        sfxKey();

        renderTyped();
        updateStats();
        levelUpIfNeeded();

        // completed?
        if (state.typed === state.answer) {
          state.score += 40; // completion bonus
          sfxGood();
          confetti(x, y, 22);
          setStatus("Success");
          updateStats();
          levelUpIfNeeded();

          // next target quickly
          setTimeout(setNewTarget, 220);
        } else {
          highlightExpectedKey();
        }
      }

      function onWrong(e, label, x, y) {
        state.total++;
        state.streak = 0;
        state.score = Math.max(0, state.score - 5);
        flashKey(label, false);
        particleBurst(x, y, 10);
        shake();
        sfxBad();
        setStatus("Wrong key");
        renderTyped();
        updateStats();
      }

      function handleKeydown(e) {
        // allow F11 for fullscreen exit
        if (e.key === "F11") return;

        // try to prevent browser shortcuts interfering
        if (e.ctrlKey || e.metaKey) return;

        // ESC prevention is limited; still try
        if (e.key === "Escape") {
          e.preventDefault();
          return;
        }

        // If not started, ignore
        if (!state.startedAt) return;

        ensureAudio();

        const rect = playPanel.getBoundingClientRect();
        const x = rect.left + rect.width * 0.5;
        const y = rect.top + rect.height * 0.45;

        const k = normalizeKey(e);

        // Backspace support in words/match
        if (state.mode !== "letters" && k === "BACKSPACE") {
          e.preventDefault();
          if (state.typed.length) {
            state.typed = state.typed.slice(0, -1);
            setStatus("Backspace");
            sfxKey();
            renderTyped();
            highlightExpectedKey();
          }
          return;
        }

        // Only accept printable characters for words/match
        if (state.mode !== "letters") {
          if (k.length !== 1 && k !== " ") {
            return;
          }
        }

        // Determine expected char/key
        if (state.mode === "letters") {
          const expected = state.answer.toUpperCase();
          const got = (k.length === 1 ? k.toUpperCase() : k);

          if (got === expected) {
            state.typed = state.answer; // done
            onCorrect(e, expected, x, y);
          } else if (got.length === 1) {
            onWrong(e, got, x, y);
          }
          return;
        }

        // words/match: compare next character
        const expected = state.answer[state.typed.length];
        if (expected == null) return;

        // For comparison, keep it exact (supports accents).
        if (k === expected) {
          state.typed += k;
          const label = (k === " " ? " " : k.toUpperCase());
          onCorrect(e, label, x, y);
        } else {
          // wrong printable input
          if (k.length === 1 || k === " ") {
            const label = (k === " " ? " " : k.toUpperCase());
            onWrong(e, label, x, y);
          }
        }
      }

      // -------------------------
      // Start / Reset / Next
      // -------------------------
      async function enterFullscreen() {
        if (document.fullscreenElement) return;
        await document.documentElement.requestFullscreen();
      }

      function startGame() {
        ensureAudio();
        state.startedAt = performance.now();
        setNewTarget();
        updateStats();
        overlay.style.display = "none";
        setStatus("Started");
      }

      function resetGame() {
        state.score = 0;
        state.streak = 0;
        state.hits = 0;
        state.total = 0;
        state.level = 1;
        state.typedCharsForWpm = 0;
        state.startedAt = performance.now();
        setNewTarget();
        updateStats();
        setStatus("Reset");
      }

      btnNext.addEventListener("click", () => setNewTarget());
      btnReset.addEventListener("click", () => resetGame());

      modeSel.addEventListener("change", () => {
        state.mode = modeSel.value;
        setNewTarget();
      });

      langSel.addEventListener("change", () => {
        state.lang = langSel.value;
        setNewTarget();
      });

      diffSel.addEventListener("change", () => {
        state.diff = diffSel.value;
        setNewTarget();
      });

      btnStart.addEventListener("click", async () => {
        ensureAudio();
        try { await enterFullscreen(); } catch { }
        startGame();
      });

      btnNoFs.addEventListener("click", () => {
        ensureAudio();
        startGame();
      });

      // Try to discourage leaving fullscreen via ESC (not reliable)
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") e.preventDefault();
      });

      document.addEventListener("keydown", handleKeydown);

      // -------------------------
      // Init
      // -------------------------
      buildKeyboard();
      updateStats();
      setNewTarget(); // prefill

      // If you want to load external datasets, uncomment and provide files:
      // (async () => {
      //   await loadExternal("en", "./words_en.json");
      //   await loadExternal("hu", "./words_hu.json");
      //   await loadExternal("de", "./words_de.json");
      // })();

    })();
  </script>
</body>

</html>